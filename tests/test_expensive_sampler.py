from __future__ import annotations

import pytest
import time
import unittest
from concurrent.futures import FIRST_COMPLETED, Future, ProcessPoolExecutor, wait

from benchmark_simulator import ObjectiveFuncWrapper

import numpy as np

from tests.utils import ON_UBUNTU, SUBDIR_NAME, cleanup, simplest_dummy_func


class DummyOptimizer:
    def __init__(
        self,
        configs: np.ndarray,
        obj_func: ObjectiveFuncWrapper,
        n_workers: int,
        unittime: float,
    ):
        self._n_workers = n_workers
        self._n_evals = len(configs)
        self._obj_func = obj_func
        self._observations: list[dict[str, float]] = []
        self._unittime = unittime
        self._configs = configs[::-1].tolist()

    def sample(self) -> dict[str, float]:
        waiting_time = (len(self._observations) + 1) * self._unittime
        time.sleep(waiting_time)
        return {"x": self._configs.pop()}

    def _pop_completed(self, futures: dict[Future, dict[str, float]]) -> None:
        completed, _ = wait(futures.keys(), return_when=FIRST_COMPLETED)
        for future in completed:
            config = futures[future]
            try:
                loss = future.result()
            except Exception as e:
                raise RuntimeError(f"An exception occurred: {e}")
            else:
                config["loss"] = loss
                self._observations.append(config.copy())

            futures.pop(future)

    def optimize(self):
        futures: dict[Future, dict[str, float]] = {}
        counts = 0
        with ProcessPoolExecutor(max_workers=self._n_workers) as executor:
            while len(self._observations) < self._n_evals:
                if counts >= self._n_workers:
                    self._pop_completed(futures)

                if counts < self._n_evals:
                    config = self.sample()
                    futures[executor.submit(self._obj_func, config)] = config
                    time.sleep(self._unittime * 1e-3)
                    counts += 1


def get_configs(index: int, unittime: float) -> np.ndarray:
    """
    [0] Slow at some points

              |0       |10       |20
              12345678901234567890123456
    Worker 1: sffffssfffff             |
    Worker 2: wsffffffsssfff           |
    Worker 3: wwsffffffwwsssssfff      |
    Worker 4: wwwsfffffwwwwwwwsssssssfff

    [1] Slow from the initialization with correct n_workers
    Usually, it does not work for most optimizers if n_workers is incorrectly set
    because opt libraries typically wait till all the workers are filled up.

              |0       |10       |20
              123456789012345678901234567890
    Worker 1: sfssfwwssssfwwwwssssssf      |
    Worker 2: wsfwsssfwwwsssssfwwwwwsssssssf

    [2] Slow from the initialization with incorrect n_workers ([2] with n_workers=4)
    Assume opt library wait till all the workers are filled up.
    `.` below stands for the waiting time due to the filling up.

              |0       |10       |20
              123456789012345678901234567
    Worker 1: sf..ssssf                 |
    Worker 2: wsf.wwwwsssssf            |
    Worker 3: wwsfwwwwwwwwwssssssf      |
    Worker 4: wwwsfwwwwwwwwwwwwwwsssssssf

    [3] No overlap

              |0       |10       |20
              1234567890123456789012345678
    Worker 1: sfffffssfffffffffffff      |
    Worker 2: wsfffffffffffffssssff      |
    Worker 3: wwsffffffffsssfffffff      |
    Worker 4: wwwsffffffffffffffffsssssfff

    The random cases were generated by:
    ```python
    size = np.random.randint(15) + 4
    print((np.random.randint(6, size=size) + 1).tolist())
    ```
    Note that I manually adapt costs of each call if their ends overlap with a start of sampling.
    It is necessary to make the test results more or less deterministic.

    The random cases were visualized with the following code:
    ```python
    import numpy as np

    def func(seq: np.ndarray):
        workers = [0, 0, 0, 0]
        strings = ["", "", "", ""]
        past = []
        before = 0
        for i, v in enumerate(seq):
            min_cumtime = min(workers)
            idx = workers.index(min_cumtime)
            before = max(workers[idx], before)
            s = sum(p <= before for p in past) + 1 if i >= 4 else 1
            strings[idx] += "w" * (before - workers[idx])
            strings[idx] += "s" * s
            strings[idx] += "f" * v
            workers[idx] = before + s + v
            before = workers[idx] - v
            past.append(workers[idx])

        for s in strings:
            print(s)

        print(np.sort(past).tolist())
    ```

    [4] Random case 1

              |0       |10       |20       |30       |40       |50       |60       |70
              123456789012345678901234567890123456789012345678901234567890123456789012345
    Worker 1: sfwwssffffffwwwwwwwwwwwwwwwwwwsssssssssfffff                              |
    Worker 2: wsfffwssssfwwwwwwwwwwwssssssssfffffwwwwwwwwwwwwwwwwwwwwwwwwwssssssssssssfff
    Worker 3: wwsffffwwwwwwwwsssssssffwwwwwwwwwwwwwwwwwwwwwwwwwsssssssssssff            |
    Worker 4: wwwsffwwwwsssssfwwwwwwwwwwwwwwwwwwwwwwwssssssssssff                       |

    [5] Random case 2

              |0       |10       |20       |30       |40
              1234567890123456789012345678901234567890123
    Worker 1: sfwwssffwwssssssffffff                    |
    Worker 2: wsfffffsssfffwwwwwwwwwwwwwwwwwwsssssssssfff
    Worker 3: wwsfffffwwwwwwwwsssssssff                 |
    Worker 4: wwwsfffffwwwwwwwwwwwwwwssssssssfff        |

    [6] Random case 3

              |0       |10       |20       |30       |40       |50       |60       |70
              12345678901234567890123456789012345678901234567890123456789012345678901234
    Worker 1: sfffssfffffwwwwwwwwwwssssssssfffffwwwwwwwwwwwwwwwwwwwwwwwwwssssssssssssfff
    Worker 2: wsffffffwwsssssfffffwwwwwwwwwwwwwwwwwwssssssssssffff                     |
    Worker 3: wwsffffsssffffffwwwwwwwwwwwwwsssssssssffff                               |
    Worker 4: wwwsffffffwwwwwssssssffffwwwwwwwwwwwwwwwwwwwwwwwsssssssssssfffff         |

    [7] Random case 4

              |0       |10       |20       |30       |40       |50       |60       |70       |80       |90       |100
              12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
    Worker 1: sffffssffffffwwwwwwwwwssssssssffffwwwwwwwwwwwwwwwwwwwwwwwwwwssssssssssssfffff                       |
    Worker 2: wsffffffwwsssssffffffwwwwwwwwwwwwwwwwwwssssssssssffffwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwssssssssssssssff
    Worker 3: wwsfffwsssffffwwwwwwwwwwwwwwwwsssssssssfffffwwwwwwwwwwwwwwwwwwwwwwwwwwwwsssssssssssssff             |
    Worker 4: wwwsfffffwwwwwwsssssssfffwwwwwwwwwwwwwwwwwwwwwwwwsssssssssssff                                      |

    [8] Random case 5

              |0       |10       |20
              123456789012345678901234567
    Worker 1: sffffwssssf               |
    Worker 2: wsffffwwwwsssssffffff     |
    Worker 3: wwsfssfffff               |
    Worker 4: wwwsffffwwwwwwwsssssssfffff
    """
    configs = [
        np.array([4, 6, 6, 5, 5, 3, 3, 3], dtype=np.float64),
        np.array([0.9] * 8, dtype=np.float64),
        np.array([0.9] * 8, dtype=np.float64),
        np.array([5, 13, 8, 16, 13, 7, 2, 3], dtype=np.float64),
        np.array([1, 3, 4, 2, 6, 1, 1, 2, 5, 5, 2, 2, 3], dtype=np.float64),
        np.array([1, 5, 5, 5, 2, 3, 6, 2, 3, 3], dtype=np.float64),
        np.array([3, 6, 4, 6, 5, 6, 5, 4, 5, 4, 4, 5, 3], dtype=np.float64),
        np.array([4, 6, 3, 5, 6, 4, 6, 3, 4, 5, 4, 2, 5, 2, 2], dtype=np.float64),
        np.array([4, 4, 1, 4, 5, 1, 6, 5], dtype=np.float64),
    ][index]
    ans = [
        np.array([5, 8, 9, 9, 12, 14, 19, 26], dtype=np.float64),
        np.array([2, 3, 5, 8, 12, 17, 23, 30], dtype=np.float64),
        np.array([2, 3, 4, 5, 9, 14, 20, 27], dtype=np.float64),
        np.array([6, 11, 15, 20, 21, 21, 21, 28], dtype=np.float64),
        np.array([2, 5, 6, 7, 11, 12, 16, 24, 35, 44, 51, 62, 75], dtype=np.float64),
        np.array([2, 7, 8, 8, 9, 13, 22, 25, 34, 43], dtype=np.float64),
        np.array([4, 7, 8, 10, 11, 16, 20, 25, 34, 42, 52, 64, 74], dtype=np.float64),
        np.array([5, 6, 8, 9, 13, 14, 21, 25, 34, 44, 53, 62, 77, 87, 101], dtype=np.float64),
        np.array([4, 5, 6, 8, 11, 11, 21, 27], dtype=np.float64),
    ][index]
    return configs * unittime, ans * unittime


@cleanup
def optimize(index: int, n_workers: int):
    unittime = 1e-1 if ON_UBUNTU else 1.0
    configs, ans = get_configs(index=index, unittime=unittime)
    wrapper = ObjectiveFuncWrapper(
        obj_func=simplest_dummy_func,
        n_workers=n_workers,
        n_actual_evals_in_opt=configs.size + 5,
        n_evals=configs.size,
        expensive_sampler=True,
        save_dir_name=SUBDIR_NAME,
    )
    opt = DummyOptimizer(
        configs=configs,
        n_workers=wrapper.n_workers,
        obj_func=wrapper,
        unittime=unittime,
    )
    opt.optimize()
    diff = np.abs(np.array(wrapper.get_results()["cumtime"]) - ans)
    print(np.array(wrapper.get_results()["cumtime"]), ans)
    assert np.all(diff < unittime * 1.5)


@pytest.mark.parametrize("index", (0, 1, 2, 3, 4, 5, 6, 7, 8))
def test_opt(index: int) -> None:
    if index == 1:
        optimize(index=index, n_workers=2)
    elif ON_UBUNTU:
        optimize(index=index, n_workers=4)


if __name__ == "__main__":
    unittest.main()
